# Domain Layer (`src/domain/`)

**Hard rule: Zero Phaser imports.** Everything here is pure TypeScript, testable without any game framework.

## Module Map

- **`branded.ts`** — Branded string types (`CustomerId`, `OrderId`, `SlotId`, `ItemId`) for compile-time ID safety. Factory functions erase to plain strings at runtime.
- **`pixel-font.ts`** — 5x7 bitmap pixel font (A-Z, 0-9, space, `$` coin icon). Exports `getGlyph`, `layoutLines`, `measureLineWidth`, `computeCenterOffset`.
- **`wallet.ts`** — Coin currency with `Wallet` interface. `initialWallet` = 20 coins. `spendCoins` returns `undefined` if can't afford. `formatCoins` renders `"$N"` with coin icon.
- **`save-game.ts`** — Legacy v1 localStorage persistence (`SaveData` version 1 + coins). Still used by `save-slots.ts` for v1→v2 migration.
- **`restaurant-type.ts`** — `RestaurantType` (`"sushi" | "bbq" | "burger"`) + `restaurantDisplayName`. Canonical import source — 9+ modules depend on this.
- **`save-slots.ts`** — Multi-slot save system (v2). `SaveSlot` (id, restaurantType, day, coins, scene, lastSaved, unlockedDishes, disabledDishes?, phase?, inventory?), `SaveStore` (version 2 + slots). Re-exports `RestaurantType` for backward compat. `loadStore` handles v2 parse → v1 migration → empty. `toggleDish(slot, dishId, allEnabled)` enables/disables individual dishes (guards against disabling the last enabled dish). `disabledDishes` is optional for backward compat — missing = all enabled. `phase` (full `Phase` union) and `inventory` are optional — old saves without them get `undefined` on load (graceful backward compat); empty inventory `{ items: [] }` is normalized to omitted. `patchSlot(slot, patch)` updates only specified fields via `SaveSlotPatch` (day, coins, scene, lastSaved, unlockedDishes, disabledDishes, phase, inventory) while preserving everything else — use instead of `createSaveSlot` when updating an existing slot. `id` and `restaurantType` are intentionally non-patchable (identity fields).
- **`snapshot.ts`** — `snapshotSlotPatch(wallet, dayCycle, inventory, now?)` → `SaveSlotPatch`. Pure function that builds a complete patch from the full game state. Single source of truth for what gets persisted — used by auto-save listeners, manual save, and any future save points.
- **`tables.ts`** — Table tracking with `TableLayout`. `createTableLayout(count)`, `seatCustomer`, `unseatCustomer`, `emptyTableIds`. Randomness stays outside domain. (Used for kitchen_prep layout; service phase now uses `TableState[]` in day-cycle.)
- **`layout.ts`** — Pure layout constraint primitives. Types: `Rect`, `Point`, `Anchor`, `Inset`, `GridSpec`, `GridCell`, `StackSpec`, `StackItem`. Functions: `canvasRect`, `insetRect`, `anchorPoint`, `anchoredRect`, `gridCells`, `stackItems`. All UI positions derive from parent rects via these composable functions.
- **`panel.ts`** — UI panel constraint resolution. `resolvePanel(spec, canvasW, canvasH)` → `ResolvedPanel`. Also exports `defaultPanelAppearance`.
- **`items.ts`** — 74 item definitions: 28 raw ($1-3, no shelf life), 31 prepped (30-120s shelf life), 15 dishes (30-60s). O(1) lookup via `findItem`. Category type: `"raw" | "prepped" | "dish"`.
- **`recipes.ts`** — 46 recipe steps with dependency chains. Methods: `"prep" | "cook" | "assemble"`. Each `RecipeStep` now carries `zone: KitchenZone | undefined` and `interaction: ZoneInteraction | undefined` (both `undefined` for assemble steps). Core abstraction: `foldRecipeTree` catamorphism with dedup. Derived: `flattenRecipeChain`, `totalRawIngredients`, `totalRecipeTime`.
- **`kitchen-zones.ts`** — Zone state machine for ingredient-level kitchen processing. Types: `KitchenZone` (`"cuttingBoard" | "stove" | "oven"`), `ZoneInteraction` (`"hold" | "flip" | "auto"`), `ZoneSlot` (empty | working | needs_flip | done), `KitchenZoneState` (cuttingBoard=1 slot, stove=3 slots, oven=2 slots, ready pile). `ZONE_CAPACITIES` record. Tick rules: `hold` advances only when `isActive=true`; `flip` pauses at 50% → `needs_flip` until `flipStoveSlot` called; `auto`/post-flip always advances; completed slot → empty + output appended to ready. Functions: `createKitchenZoneState`, `placeItemInZone` (undefined if zone full), `activateCuttingBoardSlot`, `flipStoveSlot`, `retrieveReadyItem`, `tickKitchenZones`.
- **`inventory.ts`** — Immutable inventory with FIFO removal. `removeItems` oldest-first, `removeItemSet` atomic all-or-nothing, `removeExpired` drops stale items. `executeRecipeStep` atomically consumes inputs and produces output.
- **`menu.ts`** — Per-restaurant menus with progressive dish unlocking. 5 dishes per type ($5-12). `STARTER_DISH_COUNT = 1`. `unlocked*` variants are the core implementations; full-menu functions delegate with `count=Infinity`. `shouldUnlockNextDish` checks loss/coins/capacity. Filtering helpers: `enabledDishIds(type, count, disabled)` returns unlocked minus disabled (fallback to first if all disabled); `enabledGroceryItemsFor(type, count, disabled)` and `enabledRecipesFor(type, count, disabled)` filter by enabled dishes only. `pickRandomDish` now accepts optional `disabledDishes` 4th arg.
- **`kitchen-service.ts`** — Back-of-house kitchen zone manager (pure TS, zero Phaser). Types: `KitchenServiceState` (pendingOrders, `zones: KitchenZoneState`, orderUp). Functions: `createKitchenServiceState`, `addOrderToKitchen`, `pickupFromOrderUp`, `placeIngredientInZone` (consumes from inventory + places in zone, atomic), `activateCuttingBoard` (hold mechanic), `flipStove` (flip mechanic), `assembleOrder` (atomically consumes raw items from inventory + prepped items from zones.ready → moves to orderUp), `tickKitchenService` (delegates to `tickKitchenZones`), `isKitchenIdle` (no pending orders + no active slots + ready empty + orderUp empty).
- **`day-cycle.ts`** — Day loop state machine. Phases: `grocery` → `kitchen_prep` → `service` → `day_end`. **Service phase** (FOH/BOH split): `tables: ReadonlyArray<TableState>` (per-table discriminated union: empty | customer_waiting | order_pending | in_kitchen | ready_to_serve), `kitchen: KitchenServiceState` (zone-based BOH), `playerLocation: "floor" | "kitchen"`. Key functions: `enqueueCustomer` (auto-seats or queues overflow), `takeOrder`, `sendOrderToKitchen`, `notifyOrderReady` (scene calls this explicitly after `assembleOrder`), `serveOrder`, `serveDirectFromInventory` (fast path bypassing kitchen), `movePlayer`, `tickServicePhase` (combined: patience tick + expiry + kitchen zones). **No auto-notification:** `notifyOrderReady` is scene-driven — call it after `assembleOrder` succeeds. `isRestaurantIdle` → all tables empty + kitchen idle + queue empty. Default durations: 30s/30s/120s. `activeSceneForPhase` during service uses `playerLocation` to return RestaurantScene or KitchenScene.
- **`difficulty.ts`** — Day-based difficulty scaling via `difficultyForDay(day)`. Spawn intervals (10-15s → 3-5s floor), patience (45-75s → 15-30s floor), max customers (8 → 30 cap). All monotonically scale.
- **`leaderboard.ts`** — Cross-game high scores: best day served/earnings, totals. `recordDayResult` updates. Persisted to localStorage key `"the-kitchen-competition-lb"`.
- **`balance-sim.ts`** — Pure economy simulation with seeded PRNG (mulberry32). Three buying strategies (naive, cheapest-first, profit-first). Verified: all restaurant types survive 15+ days from $20 starting coins.

## View Model Layer (`view/`)

Pure functions bridging domain state → scene-renderable data. Zero Phaser imports.

- **`format.ts`** — `formatTimeRemaining(ms)` → `"M:SS"`, `truncateName`, three-bucket classifiers via `classify3`: `timerColor` (green/yellow/red), `freshnessLevel` (fresh/warning/critical), `patienceLevel` (ok/warning/critical). Thresholds: >50% / >25% / ≤25%.
- **`timer-vm.ts`** — `timerBarVM(phase, day)` → `TimerBarVM` (fraction, label, color). Label: `"DAY {day} - {PHASE} {M:SS}"`. Returns `undefined` for `day_end`.
- **`inventory-vm.ts`** — `inventoryVM(inventory, now)` → grouped dishes + prepped items with freshness levels. Names truncated to 12 chars.
- **`grocery-vm.ts`** — `groceryVM(wallet, inventory, restaurantType, unlockedCount, disabledDishes?)` → item list with affordability, counts, sprite keys. Names truncated to 10 chars. Uses `enabledGroceryItemsFor` to filter disabled dishes.
- **`kitchen-vm.ts`** — `kitchenVM(inventory, restaurantType, unlockedCount, activeRecipe, now, disabledDishes?)` → recipe list with craftability, input have/need, active cooking progress. Uses `enabledRecipesFor` to filter disabled dishes.
- **`day-end-vm.ts`** — `dayEndVM(phase, day, wallet, restaurantType, currentUnlocked)` → earnings summary + dish unlock decision (`DishUnlockVM`).
- **`restaurant-vm.ts`** — `restaurantVM(phase, inventory, restaurantType, unlockedCount)` → `RestaurantVM` with per-table `TableVM` (including `action?: "take_order" | "send_to_kitchen" | "serve"`), `kitchenBadge: number` (count of ready-to-pickup orders in orderUp), and `playerLocation`. Replaces old global `actionPrompt`.
- **`kitchen-service-vm.ts`** — `kitchenServiceVM(kitchen, inventory)` → `KitchenServiceVM`. Types: `ZoneSlotVM` (slotIndex, tag, outputItemId, outputName, spriteKey, progressFraction, isActive, needsFlip), `KitchenZoneVM` (zone, label, slots), `PendingOrderVM` (orderId, dishName, dishSpriteKey, components: ComponentStatus[], isAssemblable), `KitchenServiceVM` (pendingOrders, zones, ready pile, orderUp). `ComponentStatus.status` is `"needed" | "in_zone" | "ready"` — computed by checking zones.ready then active zone slots. Takes `inventory` to evaluate `isAssemblable` for raw items. Used by KitchenScene in service mode.
- **`scene-layout.ts`** — Centralized layout presets derived from `layout.ts` primitives. Exports named positions/regions for all scenes: `canvas`, `gameplayPanel`, `timerBar`, `skipButtonPos`, `coinHudPos`, `groceryGrid()`, `recipeRegion`, `recipeStack()`, `kitchenInvRegion`, `tablePositions()`, `sidebarAnchor`, `hintRegion`, `notificationPos`, `menuStack()`. Zone layout: `serviceOrdersRegion` (x:10, w:150 — pending orders list), `serviceZoneRegion` (x:170, w:400 — zone panels), `servicePantryRegion` (x:580, w:210 — tappable ingredients), `serviceReadyRegion` (x:170, y:470 — ready pile), `ZONE_PANEL_H=90`, `ZONE_PANEL_GAP=8`. All magic numbers live here; scenes import instead of hardcoding.

## Testing

- **Vitest** + **fast-check** for property-based tests on domain invariants.
- Test files: `src/domain/__tests__/*.test.ts`, view model tests in `__tests__/view/`.
- `algebraic-properties.test.ts` — Cross-module property tests: wallet monoid, inventory consistency, removeExpired idempotence, timer/difficulty monotonicity, menu prefix, leaderboard max, classify3 boundaries, spend/afford consistency.
- `kitchen-zones.test.ts` — 36 tests for zone state machine: create, place, activate cutting board, flip stove, tick (hold/flip/auto mechanics, multi-slot independence), retrieve ready item, property tests (non-negative progress, ready pile size invariants).
- `service-phase.test.ts` — 51 tests for the FOH/BOH service model: happy-path lifecycle (empty→customer_waiting→order_pending→in_kitchen→ready_to_serve→empty), zone-based kitchen behavior (placeIngredientInZone, activateCuttingBoard, flipStove, assembleOrder), patience ticking across all table states, expired customer removal, `isRestaurantIdle`, property-based customer conservation. Key change: `tickServicePhase` does NOT auto-notify tables — `notifyOrderReady` is scene-driven.
- Coverage scoped to `src/domain/` only.
